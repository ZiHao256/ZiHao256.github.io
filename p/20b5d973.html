<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Lab 0 | ZiHao's Blog</title><meta name="keywords" content="操作系统"><meta name="author" content="zihao"><meta name="copyright" content="zihao"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Lab 0[toc]  ucore运行环境：X86 硬件模拟器，QEMU、VirtualBox、VMware Player ucore开发环境：GCC的gcc、gas、ld和MAKE，或集成开发环境Eclipse-CDT 分析源代码：understand 软件开发版本管理：GIT、SVN 比较文件和目录的不同，发现不同实验中的差异性和进行文件合并操作：meld、kdiff3、UltraCompar">
<meta property="og:type" content="article">
<meta property="og:title" content="Lab 0">
<meta property="og:url" content="https://zihao256.github.io/p/20b5d973.html">
<meta property="og:site_name" content="ZiHao&#39;s Blog">
<meta property="og:description" content="Lab 0[toc]  ucore运行环境：X86 硬件模拟器，QEMU、VirtualBox、VMware Player ucore开发环境：GCC的gcc、gas、ld和MAKE，或集成开发环境Eclipse-CDT 分析源代码：understand 软件开发版本管理：GIT、SVN 比较文件和目录的不同，发现不同实验中的差异性和进行文件合并操作：meld、kdiff3、UltraCompar">
<meta property="og:locale">
<meta property="og:image" content="https://raw.githubusercontent.com/ZiHao256/ZiHao256.github.io/hexo/images/wallhaven13.jpg">
<meta property="article:published_time" content="2021-05-05T16:00:00.000Z">
<meta property="article:modified_time" content="2023-10-03T05:07:27.651Z">
<meta property="article:author" content="zihao">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/ZiHao256/ZiHao256.github.io/hexo/images/wallhaven13.jpg"><link rel="shortcut icon" href="https://github.com/ZiHao256/ZiHao256.github.io/blob/hexo/images/stitch.JPG?raw=true"><link rel="canonical" href="https://zihao256.github.io/p/20b5d973"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Lab 0',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2023-10-03 13:07:27'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="//at.alicdn.com/t/c/font_4263496_xe5w6zp8g5c.css"><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="ZiHao's Blog" type="application/atom+xml">
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}</style></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://github.com/ZiHao256/ZiHao256.github.io/blob/hexo/images/stitch.JPG?raw=true" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">60</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">39</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">16</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/log"><i class="fa-fw fas fa-book"></i><span> Log</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fa fa-camera-retro"></i><span> Gallery</span></a></li><li><a class="site-page child" href="/Map/"><i class="fa-fw fa fa-map-signs"></i><span> Map</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://raw.githubusercontent.com/ZiHao256/ZiHao256.github.io/hexo/images/wallhaven13.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">ZiHao's Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/log"><i class="fa-fw fas fa-book"></i><span> Log</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fa fa-camera-retro"></i><span> Gallery</span></a></li><li><a class="site-page child" href="/Map/"><i class="fa-fw fa fa-map-signs"></i><span> Map</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Lab 0</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-05-05T16:00:00.000Z" title="Created 2021-05-06 00:00:00">2021-05-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-10-03T05:07:27.651Z" title="Updated 2023-10-03 13:07:27">2023-10-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E6%97%A0%E6%AD%A2%E5%A2%83/">学无止境</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E6%97%A0%E6%AD%A2%E5%A2%83/%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/">课程实验</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word count:</span><span class="word-count">10.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading time:</span><span>37min</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Lab 0"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">Comments:</span><a href="/p/20b5d973.html#post-comment"><span class="gitalk-comment-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Lab-0"><a href="#Lab-0" class="headerlink" title="Lab 0"></a>Lab 0</h1><p>[toc]</p>
<ul>
<li>ucore运行环境：X86 硬件模拟器，QEMU、VirtualBox、VMware Player</li>
<li>ucore开发环境：GCC的gcc、gas、ld和MAKE，或集成开发环境Eclipse-CDT</li>
<li>分析源代码：understand</li>
<li>软件开发版本管理：GIT、SVN</li>
<li>比较文件和目录的不同，发现不同实验中的差异性和进行文件合并操作：meld、kdiff3、UltraCompare</li>
<li>调试（debug）发现设计中得出错误：gdb（配合QEMU）等调试工具软件</li>
</ul>
<h1 id="1-安装一个操作系统的开发过程："><a href="#1-安装一个操作系统的开发过程：" class="headerlink" title="1 安装一个操作系统的开发过程："></a>1 <strong>安装一个操作系统的开发过程：</strong></h1><ol>
<li><strong>Bootloader+toy ucore:</strong> 理解操作系统启动前的硬件状态和要做的准备工作，了解运行操作系统的外设硬件支持，操作系统如何加载到内存中，理解两类中断—“外设中断”，“陷阱中断”，内核态和用户态的区别；</li>
<li><strong>物理内存管理：</strong>理解x86分段/分页模式，了解操作系统如何管理物理内存；</li>
<li><strong>虚拟内存管理：</strong>理解OS虚存的基本原理和目标，以及如何结合页表+中断处理（缺页故障处理）来实现虚存的目标，如何实现基于页的内存替换算法和替换过程；</li>
<li><strong>内核线程管理：</strong>理解内核线程创建、执行、切换和结束的动态管理过程，以及内核线程的运行周期等；</li>
<li><strong>用户进程管理：</strong>理解用户进程创建、执行、切换和结束的动态管理过程，以及在用户态通过系统调用得到内核中各种服务的过程；</li>
<li><strong>处理器调度：</strong>理解操作系统的调度过程和调度算法；</li>
<li><strong>同步互斥与进程间通信：</strong>理解同步互斥的具体实现以及对系统性能的影响，研究死锁产生的原因，如何避免死锁，以及线程/进程间如何进行信息交换和共享；</li>
<li><strong>文件系统：</strong>理解文件系统的具体实现，与进程管理和内存管理等的关系，缓存对操作系统IO访问的性能改进，虚拟文件系统（VFS）、buffer cache和disk driver之间的关系。</li>
</ol>
<ul>
<li>每个开发步骤都是建立在上一个步骤之上的</li>
<li>从理解操作系统原理到实践操作系统设计与实现的探索过程</li>
</ul>
<p><img src="https://static.sitestack.cn/projects/simple_os_book/bf9d40a8440c97f51c06416e01c91a5f.png" alt="ucore操作系统架构"></p>
<h1 id="2-实验环境"><a href="#2-实验环境" class="headerlink" title="2 实验环境"></a>2 实验环境</h1><h2 id="2-1-使用-Linux-实验环境"><a href="#2-1-使用-Linux-实验环境" class="headerlink" title="2.1 使用 Linux 实验环境"></a>2.1 使用 Linux 实验环境</h2><ul>
<li><p>安装 Ubuntu Linux 20.04</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_31939617/article/details/100114546">参考博客</a></li>
<li>姓名：zihao</li>
<li>密码：123456</li>
<li>注意：不要 skip</li>
</ul>
</li>
<li><p>命令行方式的编译、调试、运行操作系统</p>
</li>
<li><p>命令模式的基本结构和概念：实现需要的所有操作</p>
</li>
<li><p>进入命令模式：GNOME菜单-&gt;附件-&gt;终端</p>
</li>
<li><p>命令行终端提示符：表示计算机已就绪，等待用户输入操作指令。此时输入任何指令按回车后，该指令将会被提交到计算机运行</p>
</li>
<li><p><strong>常用指令</strong>：</p>
<ul>
<li>ls：查询文件列表<ul>
<li>ls /: 列出根目录</li>
<li>ls -l: 列出更详细的文件清单</li>
<li>ls -a:列出包括隐藏文件（以.开头的文件）</li>
</ul>
</li>
<li>pwd：查询当前所在目录</li>
<li>cd /目录路径 : 进入其他目录</li>
<li>echo “字符串”: 在屏幕输出字符</li>
<li>cat：显示文件内容<ul>
<li>less/more作为选项显示比较大的文件内容</li>
</ul>
</li>
<li>cp: 复制文件</li>
<li>mv：移动文件</li>
<li>touch：建立一个空文本文件</li>
<li>mkdir：建立一个目录</li>
<li>rm：删除文件/目录</li>
</ul>
</li>
<li><p><strong>选项</strong>：</p>
<ul>
<li>-p: 让系统显示某一项的类型，比如是文件/文件夹/快捷链接</li>
<li>-i（interactive）：在系统删除操作前输出确定指示</li>
<li>-r（recursive）: 删除文件夹</li>
</ul>
</li>
<li><p><strong>其他基本指令</strong>：</p>
<ul>
<li>ps：查询当前进程<ul>
<li>列出所启动的所有进程</li>
<li>-a : 列出所有的（包括其他用户）</li>
<li>ps auxww:  列出除一些特殊进程以外的所有进程，并会以一个高可读的形式显示结果，每一个进程都会有较为详细的解释</li>
</ul>
</li>
</ul>
</li>
<li><p>控制流程</p>
<ul>
<li><p>输入/输出</p>
<ul>
<li>input：读取通过标准输入设备输入的信息</li>
<li>output：输出指定的输出内容。在遇到操作错误时，系统会自动调用这个命令输出标准错误提示</li>
</ul>
</li>
<li><p>重定向</p>
</li>
<li><p>管道：把几个简单命令联合成为复杂的功能</p>
<ul>
<li><code>|</code><ul>
<li><code>grep -i command &lt; myfile | sort &gt; result.text</code></li>
<li>搜索myfile中的命令，将输出分类并写入到分类文件result.text</li>
</ul>
</li>
</ul>
</li>
<li><p>后台进程：要启动一个进程到后台，追加 &amp; 到命令后面</p>
<ul>
<li><code>sleep 60 &amp;</code></li>
<li>睡眠命令在后台运行，宁依然可以与计算机交互。除了不同步启动命令外，</li>
<li>如果一个命令将占用很多时间，想让其放入后台运行</li>
<li><blockquote>
<p>sleep 60</p>
<p>&lt; ctrl z&gt;   # 停止</p>
<p>bg  #转入后台</p>
<p>fg  # 转回前台</p>
</blockquote>
</li>
<li><code>ctrl c</code>:杀死一个前台程序</li>
</ul>
</li>
</ul>
</li>
<li><p>环境变量</p>
</li>
<li><p>获得软件包</p>
<ul>
<li><p>命令行获取软件包</p>
<ul>
<li><p><code>apt-get</code>: 自动从互联网软件库中搜索、安装、升级以及卸载软件或者操作系统</p>
</li>
<li><p>一般需要root 执行权限</p>
</li>
<li><p>语法 <code>sudo apt-get install gcc</code></p>
</li>
<li><p>常见 apt 命令：</p>
<ul>
<li><blockquote>
<p>apt-get install <code>&lt;package&gt;</code> # 下载<code>&lt;package&gt;</code> 以及所依赖的软件包，同时进行软件包的安装或者升级</p>
<p>apt-get remove <code>&lt;package&gt;</code> #移除<code>&lt;package&gt;</code>以及所依赖的软件包</p>
<p>apt-cache search <code>&lt;pattern&gt;</code> #搜索满足pattern 的软件包</p>
<p>apt-cache show/showpkg <code>&lt;package&gt;</code> #显示软件包 <code>&lt;package&gt;</code> 的完整描述</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>解决 apt 下载速度太慢：</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34246778/article/details/92849180">选择最佳服务器</a></li>
</ul>
</li>
<li><p>图形界面软件包获取</p>
<ul>
<li><code>菜单栏-&gt;系统管理 -&gt; 新德里软件包管理器</code></li>
</ul>
</li>
<li><p>配置升级源</p>
<ul>
<li><blockquote>
<p>Ubuntu的软件包获取依赖升级源，可以通过修改 “/etc/apt/sources.list” 文件来修改升级源（需要 root 权限）；或者修改新立得软件包管理器中 “设置 &gt; 软件库”。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p>查找帮助文件</p>
<ul>
<li>命令 <code>man</code></li>
<li>对 Linux 下常用命令、安装软件、以及C语言常用函数进行查询</li>
<li>语法 <code>man 命令</code></li>
</ul>
</li>
</ul>
<h2 id="2-2-可能用到的软件"><a href="#2-2-可能用到的软件" class="headerlink" title="2.2 可能用到的软件"></a>2.2 可能用到的软件</h2><ul>
<li><p><strong>编辑器</strong></p>
<ul>
<li><p>gnome</p>
</li>
<li><p><strong>Vim</strong></p>
<ul>
<li><p>下载安装VIm <code>sudo spt-get install vim</code></p>
</li>
<li><p>查看 vim 版本命令 <code>vim --version</code></p>
</li>
<li><p>编辑配置文件至 <code>~/.vimrc</code></p>
<ul>
<li><blockquote>
<p>在启动vim时，当前用户根目录下的.vimrc文件会被自动读取，该文件可以包含一些设置甚至脚本，所以，一般情况下把.vimrc文件创建在当前用户的根目录下比较方便</p>
</blockquote>
</li>
</ul>
</li>
<li><blockquote>
<p>```<br>set nocompatible<br>set encoding=utf-8<br>set fileencodings=utf-8,chinese<br>set tabstop=4<br>set cindent shiftwidth=4<br>set backspace=indent,eol,start<br>autocmd Filetype c set omnifunc=ccomplete#Complete<br>autocmd Filetype cpp set omnifunc=cppcomplete#Complete<br>set incsearch<br>set number<br>set display=lastline<br>set ignorecase<br>syntax on<br>set nobackup<br>set ruler<br>set showcmd<br>set smartindent<br>set hlsearch<br>set cmdheight=1<br>set laststatus=2<br>set shortmess=atI<br>set formatoptions=tcrqn<br>set autoindent </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* **exuberant-ctags:** 为程序语言对象生成索引，其结果能够被一个文本编辑器或者其他工具简捷迅速的定位</span><br><span class="line"></span><br><span class="line"># 3 了解编程开发调试的基本工具</span><br><span class="line"></span><br><span class="line">## 3.1 gcc 的基本用法</span><br><span class="line"></span><br><span class="line">* 使用 vim 编辑一个 .c 文件</span><br><span class="line">* 用 gcc 编译文件：`gcc -Wall hello.c -o hello`</span><br><span class="line"></span><br><span class="line"> * &gt; 该命令将文件‘hello.c’中的代码**编译**为机器码并**存储**在可执行文件 ‘hello’中。机器码的文件名是通过 -o 选项指定的。该选项通常作为命令行中的最后一个参数。如果被省略，输出文件默认为 ‘a.out</span><br><span class="line"></span><br><span class="line">* `-Wall`: 开启编译器几乎所有常用的警告</span><br><span class="line">* 运行可执行文件：输入可执行文件的路径</span><br><span class="line"></span><br><span class="line"> * `./hello`</span><br><span class="line"> * &gt; 该命令将可执行文件**载入内存**，并**使CPU开始执行**其包含的指令</span><br><span class="line"></span><br><span class="line">./ 当前目录</span><br><span class="line"></span><br><span class="line">因此 `./hello`: 载入并执行当前目录下的可执行文件 hello</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 3.1.1 AT &amp; T汇编基本语法</span><br><span class="line"></span><br><span class="line">* Ucore 用的是 AT&amp;T 格式的汇编</span><br><span class="line"></span><br><span class="line"> * 1.**寄存器引用**： 在寄存器号前加 `%`</span><br><span class="line"> * 2.**操作数顺序**：从左到右</span><br><span class="line"> * 3.**立即数**：在数前面加 `$`</span><br><span class="line">   * 16 进制常数：`0x $`</span><br><span class="line"> * 4**.符号常数**：直接引用</span><br><span class="line">   * 在前加 `$`：引用符号地址</span><br><span class="line"> * 5.**操作数长度**：加在指令后</span><br><span class="line">   * b : 8-bit</span><br><span class="line">   * w: 16-bit</span><br><span class="line">   * l: 32-bit</span><br><span class="line">   * 若没有指定操作数长度，编译器按照**目标操作数**的长度来设置</span><br><span class="line"> * 6**.内存引用**：</span><br><span class="line">   * Intel 格式的简介内存引用：</span><br><span class="line">     * `section:[base+index*scale+displacement]`</span><br><span class="line">   * AT&amp;T 格式的间接内存引用：</span><br><span class="line">     * `section:displacement(base,index,scale)`</span><br><span class="line">* 与 Intel格式的汇编的不同</span><br><span class="line"></span><br><span class="line"> * </span><br><span class="line"> * ```</span><br><span class="line">   * 寄存器命名原则</span><br><span class="line">           AT&amp;T: %eax                      Intel: eax</span><br><span class="line">       * 源/目的操作数顺序 </span><br><span class="line">           AT&amp;T: movl %eax, %ebx           Intel: mov ebx, eax</span><br><span class="line">       * 常数/立即数的格式　</span><br><span class="line">           AT&amp;T: movl $_value, %ebx        Intel: mov eax, _value</span><br><span class="line">         把value的地址放入eax寄存器</span><br><span class="line">           AT&amp;T: movl $0xd00d, %ebx        Intel: mov ebx, 0xd00d</span><br><span class="line">       * 操作数长度标识 </span><br><span class="line">           AT&amp;T: movw %ax, %bx             Intel: mov bx, ax</span><br><span class="line">       * 寻址方式 </span><br><span class="line">           AT&amp;T:   immed32(basepointer, indexpointer, indexscale)</span><br><span class="line">           Intel:  [basepointer + indexpointer × indexscale + imm32)</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
</li>
<li><p>OS 工作于保护模式下时，用 32 位线性地址，所以在计算地址时不用考虑 segment ：offse</p>
</li>
<li><p>上式中的地址 <code>immed32+basepointer+indexpointer*indexscale</code></p>
</li>
<li><p>```</p>
<pre><code>* 直接寻址 
        AT&amp;T:  foo                         Intel: [foo]
        foo是一个全局变量。注意加上$是表示地址引用，不加是表示值引用。对于局部变量，可以通过堆栈指针引用。

* 寄存器间接寻址 
        AT&amp;T: (%eax)                        Intel: [eax]

* 变址寻址 
        AT&amp;T: _variable(%eax)               Intel: [eax + _variable]
        AT&amp;T: _array( ,%eax, 4)             Intel: [eax × 4 + _array]
        AT&amp;T: _array(%ebx, %eax,8)          Intel: [ebx + eax × 8 + _array]
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 3.1.4 GCC 基本内联汇编</span><br><span class="line"></span><br><span class="line">* GCC 支持在 C++ 代码中嵌入汇编代码：GCC Inline ASM——GCC 内联汇编</span><br><span class="line"></span><br><span class="line">  * 有利于将一些C++无法表达的指令直接嵌入</span><br><span class="line">  * 允许我们直接写汇编，来编写简洁代码</span><br><span class="line">* GCC 提供了两内联汇编语句（Inline asm statements）:</span><br><span class="line"></span><br><span class="line">  * 基本内联汇编语句（basic inline asm statements）</span><br><span class="line">    * 格式：`asm(&quot;statements&quot;);`</span><br><span class="line">  * 扩展内联汇编语句（extended inline asm statements）</span><br><span class="line">* `&quot;asm&quot;`和 `“_asm_”`的含义一致: 声明一个内联汇编表达式</span><br><span class="line"></span><br><span class="line">  * asm 是 GCC 关键字 asm的宏定义</span><br><span class="line">    * `#define _asm_ asm`</span><br><span class="line">* 若有多行汇编，每行最后加 `\n\t`</span><br><span class="line"></span><br><span class="line">  * \n : 换行符</span><br><span class="line">  * \t : tab符号</span><br><span class="line">  * 为了 使得 gcc 在编译内联汇编代码，成为一般的汇编代码时能够保证换行，和有一定的空格</span><br><span class="line">  * GCC 编译出来的汇编代码就是双引号中的内容</span><br><span class="line">* gcc 在处理汇编时，把asm（）的内容打印到汇编文件中，格式控制字符是必要的</span><br><span class="line">* ```</span><br><span class="line">      asm(&quot;movl %eax, %ebx&quot;);</span><br><span class="line">      asm(&quot;xorl %ebx, %edx&quot;);</span><br><span class="line">      asm(&quot;movl $0, _boo);</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>在上面的例子中，由于我们在<strong>内联汇编</strong>中改变了 edx 和 ebx 的值，但是由于 gcc 的特殊的处理方法，即先形成汇编文件，再交给 GAS 去汇编，所以 GAS 并不知道我们已经改变了 edx和 ebx 的值，如果程序的上下文需要 edx 或 ebx 作其他内存单元或变量的暂存，就会产生没有预料的多次赋值，引起严重的后果。对于变量 _boo也存在一样的问题。为了解决这个问题，就要用到<strong>扩展 GCC 内联汇编语法</strong>。</p>
</blockquote>
</li>
</ul>
<h3 id="3-1-5-GCC-扩展内联汇编"><a href="#3-1-5-GCC-扩展内联汇编" class="headerlink" title="3.1.5 GCC 扩展内联汇编"></a>3.1.5 GCC 扩展内联汇编</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u014160900/article/details/44900303">参考博客</a></p>
<ul>
<li><blockquote>
<pre><code>#define read_cr0() (&#123; \
 unsigned int __dummy; \
 __asm__( \
     &quot;movl %%cr0,%0\n\t&quot; \
     :&quot;=r&quot; (__dummy)); \ 
 __dummy; \
&#125;)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* GCC 扩展内联汇编基本格式</span><br><span class="line"></span><br><span class="line"> * &gt; asm [volatile] (Assembler Template</span><br><span class="line"></span><br><span class="line">    : Output operands</span><br><span class="line"></span><br><span class="line">    [ : Input Operands</span><br><span class="line"></span><br><span class="line">    [ : Clobbers  ] ] )</span><br><span class="line"></span><br><span class="line"> * asm 代表汇编代码的开始</span><br><span class="line"> * [volatile] : 可选项，避免 asm 指令被删除、移动或组合</span><br><span class="line"> * 指令 `“movl %%cr0,%0\n\t”`</span><br><span class="line"> * 数字前缀：`%1`, 表示使用寄存器的样板操作数</span><br><span class="line"></span><br><span class="line">   * 指令中几个操作数，表示有几个变量需要与寄存器结合，由gcc在编译时根据后面的输出部分和输入部分的约束条件进行相应的处理</span><br><span class="line">   * 可使用的操作数总数取决于具体CPU中通用寄存器的数量</span><br><span class="line">   * `%%cr0`: 两个 % ，表示用到具体的寄存器</span><br><span class="line"> * Output Operands list：输出部分，用以规定对输出变量（目标操作数）如何与寄存器结合的约束（constraint）。输出部分可以有多个约束，以逗号分开</span><br><span class="line"></span><br><span class="line">   * 每个约束语法：`“=约束字母” 关于变量结合的约束`</span><br><span class="line">   * `:&quot;=r&quot; (_dummy)`</span><br><span class="line"></span><br><span class="line">     * =r 表示相应的目标操作数（%0），可以使用任何一个通用寄存器，并且变量 _dummy 存放在这个寄存器中</span><br><span class="line">   * `:&quot;=m&quot; (_dummy)`</span><br><span class="line"></span><br><span class="line">     * =m 表示相应的目标操作数是存放在内存单元 _dummy 中</span><br><span class="line">   * 几个主要的约束字母</span><br><span class="line"></span><br><span class="line">     | 字母       | 含义                                             |</span><br><span class="line">     | ---------- | ------------------------------------------------ |</span><br><span class="line">     | m, v, o    | 内存单元                                         |</span><br><span class="line">     | R          | 任何通用寄存器                                   |</span><br><span class="line">     | Q          | 寄存器eax, ebx, ecx,edx之一                      |</span><br><span class="line">     | I, h       | 直接操作数                                       |</span><br><span class="line">     | E, F       | 浮点数                                           |</span><br><span class="line">     | G          | 任意                                             |</span><br><span class="line">     | a, b, c, d | 寄存器eax/ax/al, ebx/bx/bl, ecx/cx/cl或edx/dx/dl |</span><br><span class="line">     | S, D       | 寄存器esi或edi                                   |</span><br><span class="line">     | I          | 常数（0～31）                                    |</span><br><span class="line"> * ==Input Operand list: 输入部分==</span><br><span class="line"></span><br><span class="line">   * 与输出部分相似，但没有 `=`</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line"></span><br><span class="line">### 3.1.6 **Extended Asm**</span><br><span class="line"></span><br><span class="line">[参考博客](https://www.jianshu.com/p/1782e14a0766)</span><br><span class="line"></span><br><span class="line">* 内联函数：在C语言中，指定编译器将一个函数代码直接复制到调用其代码的地方执行。</span><br><span class="line"></span><br><span class="line"> * 内联函数降低了函数的调用开销</span><br><span class="line"> * 指定编译器将一个函数处理为内联函数，只要在函数申明前加上 inline 关键字</span><br><span class="line">* 内联汇编：用汇编语句写成的内联函数</span><br><span class="line"></span><br><span class="line"> * GCC（CNU Compiler Collection for Linux） 中声明一个内联汇编函数，用 asm 关键字</span><br><span class="line"> * 操作 C 语言变量</span><br><span class="line">* 在扩展形式中，可以指定操作数，选择输入输出寄存器，指明要修改的寄存器列表</span><br><span class="line">* 形式：</span><br><span class="line"></span><br><span class="line"> * ```cpp</span><br><span class="line">   asm ( assembler template</span><br><span class="line">           : output operands                /* optional */</span><br><span class="line">           : input operands                   /* optional */</span><br><span class="line">           : list of clobbered registers   /* optional */</span><br><span class="line">   );</span><br></pre></td></tr></table></figure>
</code></pre>
</blockquote>
<ul>
<li><p><code>assembler template</code>: 汇编指令部分</p>
</li>
<li><p>括号内的operands：C 语言表达式中常量字符串，不同部分之间用冒号分隔</p>
<p>相同部分语句中的每个小部分用逗号分隔</p>
<p>最多指定10个操作数</p>
</li>
</ul>
</li>
<li><p>若没有 output operands ,有input operands，需要保留output 前的冒号</p>
<ul>
<li><p>```cpp<br>asm ( “cld\n\t”</p>
<pre><code>      &quot;rep\n\t&quot;
      &quot;stosl&quot;
     : /* no output registers */
     : &quot;c&quot; (count), &quot;a&quot; (fill_value), &quot;D&quot; (dest)
     : &quot;%ecx&quot;, &quot;%edi&quot;
  );
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">* 例子：用汇编代码把a的值赋给b</span><br><span class="line"></span><br><span class="line">  * ```php</span><br><span class="line">    int a=10, b;</span><br><span class="line">    asm ( &quot;movl %1, %%eax;</span><br><span class="line">               movl %%eax, %0;&quot;</span><br><span class="line">              :&quot;=r&quot;(b)           /* output */</span><br><span class="line">              :&quot;r&quot;(a)              /* input */</span><br><span class="line">              :&quot;%eax&quot;         /* clobbered register */</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>

<ul>
<li>b 是输出操作数，用 %0 访问</li>
<li>a 是输入操作数，用 %1 访问</li>
<li>r 是constraint：让 GCC 自己选择一个寄存器存储变量a<ul>
<li>输出部分constraint 前需要 = 修饰</li>
</ul>
</li>
<li>用 %% 和 % 区分操作数和寄存器<ul>
<li>操作数已经用一个%做前缀，寄存器只能用%%做前缀</li>
</ul>
</li>
<li>clobbered register：代表内联汇编代码会改变寄存器eax的内容</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="汇编模板（assembler-template）"><a href="#汇编模板（assembler-template）" class="headerlink" title="汇编模板（assembler template）"></a>汇编模板（assembler template）</h4><ul>
<li>嵌入在C中的汇编指令<ul>
<li>每条指令放在一个双引号内，或都在一个双引号</li>
<li>每条指令后 <code>\n\t</code></li>
<li>访问 <strong>C 语言变量</strong>用 %0，%1…</li>
</ul>
</li>
</ul>
<h4 id="操作数（Operands）"><a href="#操作数（Operands）" class="headerlink" title="操作数（Operands）"></a>操作数（Operands）</h4><ul>
<li><p>格式 <code>&quot;constraint&quot; (C expr) //&quot;=r&quot;(result)</code></p>
</li>
<li><p>asm 内部使用<strong>C语言字符串</strong>作为操作数</p>
</li>
<li><p>操作数都要放在双引号内</p>
<ul>
<li>对于 output 操作数要用 =</li>
</ul>
</li>
<li><p>constraint 和 修饰都放在双引号内</p>
</li>
<li><p>constraint：指定操作数的寻址类型（内存寻址或者寄存器寻址），也用来指明使用那个寄存器</p>
</li>
<li><p>若有多个操作数，使用逗号隔开</p>
</li>
<li><p>在汇编模板部分，按顺序用数字去引用操作数</p>
</li>
<li><p>输出操作数表达式必须是左值，输入操作数不一定是</p>
<ul>
<li>可以使用表达式或者变量</li>
</ul>
</li>
<li><p>例子：把一个数字乘以五</p>
<ul>
<li>```cpp<br>asm ( “leal (%1,%1,4), %0”<pre><code>    : &quot;=r&quot; (five_times_x)
    : &quot;r&quot; (x)
 );
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  * 输入操作数是 x，未指定具体使用那个寄存器</span><br><span class="line">* 修改 constraint 部分内容，使得 GCC 固定使用同一个寄存器处理输入输出操作数,但未指定具体哪个寄存器</span><br><span class="line"></span><br><span class="line">  * ```cpp</span><br><span class="line">    asm( &quot;lea (%0,%0,4),%0&quot;</span><br><span class="line">            : &quot;=r&quot; (five_times_x)</span><br><span class="line">            : &quot;0&quot; (x)</span><br><span class="line">        );</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>需要指定具体的寄存器</p>
<ul>
<li>```cpp<br>asm ( “leal (%%ecx,%%ecx,4), %%ecx”<pre><code>    : &quot;=c&quot; (x)
    : &quot;c&quot; (x) 
</code></pre>
);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br></pre></td><td class="code"><pre><span class="line">* 不需要填写ClobberList</span><br><span class="line"></span><br><span class="line">  * 指定GCC自己选择合适的寄存器</span><br><span class="line">  * 因为 GCC 知道x将存入 ecx ，GCC完全知道ecx的值</span><br><span class="line"></span><br><span class="line">#### 破坏列表 Clobber List</span><br><span class="line"></span><br><span class="line">* 如果某个指令改变了某个寄存器的值，就必须在第三个冒号后标识出该寄存器</span><br><span class="line">* 为了告知 GCC ，让其不在假定之前寄存器中的值依然合法</span><br><span class="line">* 输入输出寄存器不用放入Clobber List</span><br><span class="line">  * GCC 能够知道asm将使用这些寄存器</span><br><span class="line">  * 已经被显示地指定输入输出</span><br><span class="line">  * 其他使用到的寄存器无论是显示或隐式都需要标明</span><br><span class="line">* 若指令中已无法意料的形式修改了内存值，需要在 Clobber List 中加入 memory</span><br><span class="line">  * 使得 GCC 不去缓存这些内存值</span><br><span class="line">  * Clobber List 中列出的寄存器可以被多次写读</span><br><span class="line"></span><br><span class="line">#### 特征修饰符 Volatile</span><br><span class="line"></span><br><span class="line">* 要求汇编代码必须在被放置的位置执行（不能被循环优化或移除循环）</span><br><span class="line">* 禁止这些代码被移动或删除</span><br><span class="line">* `asm volatile ();`</span><br><span class="line"></span><br><span class="line">#### 约束 Constraints</span><br><span class="line"></span><br><span class="line">* 寄存器操作数 constraints：`r`</span><br><span class="line"></span><br><span class="line">  * 操作数将被存储在通用寄存器中</span><br><span class="line">  * `asm (&quot;movl %%eax, %0&quot;: &quot;=r&quot; (myval));`</span><br><span class="line"></span><br><span class="line">    * 变量 myval 将被保存在 GCC 自己选择的寄存器中</span><br><span class="line">    * eax 中的值被拷贝到这个寄存器中</span><br><span class="line">    * 在内存中的 myval 值也会按照这个寄存器值更新</span><br><span class="line">    * r GCC 可能会在任何一个可用的通用寄存器中保存这个值</span><br><span class="line">  * 具体指定使用那个寄存器：</span><br><span class="line">  * | r | Register(s)     |</span><br><span class="line">    | :- | :-------------- |</span><br><span class="line">    | a | %eax, %ax, %al  |</span><br><span class="line">    | b | %ebx, %bx, %bl  |</span><br><span class="line">    | c | %ecx, %cx, %cl  |</span><br><span class="line">    | d | %edx, %dx, %adl |</span><br><span class="line">    | S | %esi, %si       |</span><br><span class="line">    | D | %edi, %di       |</span><br><span class="line">* 内存操作数constraint：`m`</span><br><span class="line"></span><br><span class="line">  * 当操作数在内存中时，任何对其操作会直接在内存中运行</span><br><span class="line">    * 指定寄存器：内存操作时会把值存在一个寄存器中，修改后再将该值 协会到该内存中</span><br><span class="line">* 匹配 constraint</span><br><span class="line"></span><br><span class="line">#### 约束 Constraints Modifiers修饰符</span><br><span class="line"></span><br><span class="line">#### 常用代码示例</span><br><span class="line"></span><br><span class="line">## 3.2 make 和 Makefile</span><br><span class="line"></span><br><span class="line">* GNU make 是一种代码维护工具</span><br><span class="line">  * 项目中，根据程序各个模块的更新情况，自动的维护和生成目标代码</span><br><span class="line">* 执行 make 命令时，需要 makefile 文件，以告诉make命令，需要怎样去编译和链接程序</span><br><span class="line">* 编译和链接的规则</span><br><span class="line">  * 如果这个工程没有编译过，那么我们的所有c文件都要编译并被链接。</span><br><span class="line">  * 如果这个工程的某几个c文件被修改，那么我们只编译被修改的c文件，并链接目标程序。</span><br><span class="line">  * 如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的c文件，并链接目标程序。</span><br><span class="line">* 编写好 makefile 后，只需要 make 命令，就可自动的根据当前的文件修改情况来确定哪些文件需要重新编译并重新链接</span><br><span class="line"></span><br><span class="line">### 3.2.1 makefile 的规则</span><br><span class="line"></span><br><span class="line">* &gt; target ... :prerequisites ...</span><br><span class="line">  &gt;</span><br><span class="line">  &gt;     command</span><br><span class="line">  &gt;</span><br><span class="line">  &gt;     ...</span><br><span class="line">  &gt;</span><br><span class="line">  &gt;     ...</span><br><span class="line">  &gt;</span><br><span class="line"></span><br><span class="line">  * target 是一个目标文件 : 可以是 object 文件，也可以是执行文件，也可以是一个 label</span><br><span class="line">  * prerequisite：要生成那个 target 所需要的文件</span><br><span class="line">  * command：make 需要执行的命令（任意的 shell 命令）</span><br><span class="line">  * 文件依赖关系</span><br><span class="line">    * target 文件依赖于 prerequisite 中的文件</span><br><span class="line">    * 生成规则 定义在 command 中</span><br><span class="line">  * 如果 prerequisites 中有文件比 target 文件新，那么command所定义的命令就被执行</span><br><span class="line"></span><br><span class="line">##3.3  gdb 的使用</span><br><span class="line"></span><br><span class="line">[参考博客](https://wiki.ubuntu.org.cn/%E7%94%A8GDB%E8%B0%83%E8%AF%95%E7%A8%8B%E5%BA%8F#.E7.9B.B8.E5.85.B3.E8.AF.8D.E6.9D.A1)</span><br><span class="line"></span><br><span class="line">* 调试命令 `gcc -g  -Wall 原文件.c -o 输出的目标文件`</span><br><span class="line">  * -g : 调试 C/C++ 程序，在编译时，就需要把调试信息加到可执行文件中</span><br><span class="line">  * 没有 -g 的话，看不见程序函数名、变量名，而是运行时的内存代码</span><br><span class="line">* 启动 gdb ：进入 gdb 环境和加载被调试程序同时进行：</span><br><span class="line">  * `gdb 可执行文件名`</span><br><span class="line">  * `gdb 可执行文件名 core`</span><br><span class="line">    * 用gdb 同时调试一个运行程序和core文件（程序非法执行后 core dump 后产生的文件）</span><br><span class="line">  * `gdb 可执行文件名 &lt;PID&gt;`</span><br><span class="line">    * 若程序是一个服务程序，可以指定服务程序运行时的进程 ID</span><br><span class="line">* gdb 启动开关</span><br><span class="line">* `help`:查看命令种类</span><br><span class="line">  * `help 命令`：查看种类中的命令</span><br><span class="line">* 调试已运行的程序</span><br><span class="line">  * 1. `ps` 查看正在运行的程序 ID，`gdb &lt;program&gt; PID` 格式挂接正在运行的程序</span><br><span class="line">    2. `gdb &lt;program&gt;` 关联上源代码，并进行gdb，在 gdb 环境中 用 `attach` 命令来挂接进程 PID ，用 `detach` 取消挂接</span><br><span class="line">* 暂停/恢复程序运行</span><br><span class="line">  * 可以设置程序在哪行停，在什么条件下停，在受到什么信号时停</span><br><span class="line">  * `info program` 查看程序是否在运行，进程号，被暂停原因</span><br><span class="line">  * 暂停方式：</span><br><span class="line">    * BreakPoint: 断点</span><br><span class="line">    * WatchPoint: 观察点</span><br><span class="line">    * CatchPoint：捕捉点</span><br><span class="line">    * Signals：信号</span><br><span class="line">    * ThreadStops：线程停止</span><br><span class="line">  * 恢复程序运行：`c` / `continue`</span><br><span class="line"></span><br><span class="line">### 设置断点（Break Points）</span><br><span class="line"></span><br><span class="line">* `break &lt;function&gt;`: 在进入指定函数时停住</span><br><span class="line">* `break &lt;linenum&gt;`: 在指定行号停住</span><br><span class="line">* `break +offset`: 在当前行号前面的 offset 行停住</span><br><span class="line">* `break -offset`: 在当前行号后面 offset 行挺住</span><br><span class="line">* `break filename: linenum`: 在源文件 filename 的 linenum 行停住</span><br><span class="line">* `break filename: function`: 在源文件filename的function入口处同住</span><br><span class="line">* `break *address`: 在程序运行的内存地址处停住</span><br><span class="line">* `break`: 没有参数时，表示在下一条指令处停住</span><br><span class="line">* `break ... if &lt;conditon&gt;`: 在条件成立时停住</span><br><span class="line">  * `...` 是上述参数，conditon 表示条件</span><br><span class="line">* 查看断点：n 为断点号</span><br><span class="line">  * `info breakpoints [n]`</span><br><span class="line">  * `info break [n]`</span><br><span class="line"></span><br><span class="line">### 设置观察点（Watch Points）</span><br><span class="line"></span><br><span class="line">观察点一般来观察某个表达式（或变量）的值是否变化，若变化则停住</span><br><span class="line"></span><br><span class="line">* `watch &lt;expr&gt;`:  为表达式 expr 设置观察点</span><br><span class="line">* `rwatch &lt;expr&gt;`: 当表达式 expr 被读时，停住</span><br><span class="line">* `awatch &lt;expr&gt;`: 当表达式的值被读或写时，停住</span><br><span class="line">* `info watchpoints`: 列出所有观察点</span><br><span class="line"></span><br><span class="line">### 设置捕捉点（Catch Points）</span><br><span class="line"></span><br><span class="line">设置捕捉点来捕捉程序运行时的一些事件</span><br><span class="line"></span><br><span class="line">* `catch &lt;event&gt;`: 当event发生时，停住</span><br><span class="line">  * throw 一个C++ 抛出的异常</span><br><span class="line">  * catch 一个C++捕捉到的异常</span><br><span class="line">  * exec 调用系统调用 exec 时</span><br><span class="line">  * fork 调用系统调用 fork 时</span><br><span class="line">  * vfork 调用系统调用 vfork 时</span><br><span class="line">  * load</span><br><span class="line">  * unload</span><br><span class="line">* `tcatch &lt;event&gt;`: 值设置一次捕捉点，当程序停住后，该店被自动删除</span><br><span class="line"></span><br><span class="line">### 维护停止点</span><br><span class="line"></span><br><span class="line">停止点即上述三类</span><br><span class="line"></span><br><span class="line">* clear</span><br><span class="line">  * `clear` : 清除所有已定义的停止点</span><br><span class="line">  * `clear &lt;function&gt;` / `clear &lt;filename: function&gt;`: 清除所有设置在函数上的停止点</span><br><span class="line">  * `clear &lt;linenum&gt;` /  `clear &lt;filename: linenum&gt;`: 清除所有设置在指定行上的停止点</span><br><span class="line">* delete</span><br><span class="line">  * `delete [breakpoints] [range...]`: 删除指定的断点，断点号，若不指定断点号则删除所有断点。range 表示断点号范围</span><br><span class="line">* disable：gdb 不会删除，enable 可以恢复</span><br><span class="line">  * `disable [breakpoints] [range]`:</span><br><span class="line">  * `enable [breakpoints] [range]`</span><br><span class="line">  * `enable [breakpoints] once range...`</span><br><span class="line">  * `enable [breakpoints] delete range ...`</span><br><span class="line"></span><br><span class="line">### 停止条件维护</span><br><span class="line"></span><br><span class="line">断点条件设置好后，用 conditon 命令修改条件（仅break和watch支持if）</span><br><span class="line"></span><br><span class="line">* `condition &lt;bnum&gt; &lt;expr&gt;`: 修改断点号为 bnum 的停止条件为 expr</span><br><span class="line">* `condition &lt;bnum&gt;` : 清除断点号为 bnum 的停止条件</span><br><span class="line"></span><br><span class="line">### 为停止点设定运行命令</span><br><span class="line"></span><br><span class="line">### 断电菜单</span><br><span class="line"></span><br><span class="line">### 恢复程序运行和单步调试</span><br><span class="line"></span><br><span class="line">当程序被停住，可以用 continue 命令恢复程序运行直到结束，或下一个断点，</span><br><span class="line"></span><br><span class="line">也可以使用 step 或 next 命令单步跟踪程序</span><br><span class="line"></span><br><span class="line">* `continue [ignore-count]` / c / fg</span><br><span class="line">  * 恢复程序运行至结束或者下一个断点</span><br><span class="line">  * 或者设置忽略的次数</span><br><span class="line">* `step &lt;count&gt;`</span><br><span class="line">  * 单步跟踪，若有函数调用会进入函数</span><br><span class="line">* `next &lt;count&gt;`</span><br><span class="line">  * 单步跟踪，若有函数调用，不会进入函数</span><br><span class="line">* `set step-mod`</span><br><span class="line">* `set step-mod on`</span><br><span class="line">* `set step-mod off`</span><br><span class="line">* `finish`</span><br><span class="line">* `until / u`</span><br><span class="line">  * 退出循环体</span><br><span class="line">* `stepi`</span><br><span class="line">* `nexti`</span><br><span class="line"></span><br><span class="line">### 信号（Signals）</span><br><span class="line"></span><br><span class="line">### 线程（Thread Stops）</span><br><span class="line"></span><br><span class="line">* 功能强大的调试程序</span><br><span class="line"></span><br><span class="line">  * 设置断点</span><br><span class="line">  * 监视程序变量的值</span><br><span class="line">  * 程序的单步执行</span><br><span class="line">  * 显示/修改变量的值</span><br><span class="line">  * 显示/修改寄存器</span><br><span class="line">  * 查看程序的堆栈情况</span><br><span class="line">  * 远程调试</span><br><span class="line">  * 调试线程</span><br><span class="line">* 必须先用 -g 或 -ggdb 编译选项编译源文件，才能使用 gdb 调试程序</span><br><span class="line"></span><br><span class="line">  * 运行 gdb 调试程序命令：`gdb progname`</span><br><span class="line">* 在 gdb 提示符处键入 help ，</span><br><span class="line"></span><br><span class="line">  * aliases：命令别名</span><br><span class="line">  * breakpoints：断点定义</span><br><span class="line">  * data：数据查看</span><br><span class="line">  * files：指定并查看文件</span><br><span class="line">  * internals：维护命令</span><br><span class="line">  * running：程序执行</span><br><span class="line">  * stack：调用栈查看</span><br><span class="line">  * status：状态查看</span><br><span class="line">  * tracepoints: 跟踪程序执行</span><br><span class="line">* `help 命令`：该命令的详细</span><br><span class="line">* gdb 常用命令</span><br><span class="line"></span><br><span class="line">  * | break FILENAME:NUM | 在特定源文件特定行上设置断点                            |</span><br><span class="line">    | ------------------ | ------------------------------------------------------- |</span><br><span class="line">    | clear FILENAME:NUM | 删除设置在特定源文件特定行上的断点                      |</span><br><span class="line">    | run                | 运行调试程序                                            |</span><br><span class="line">    | step               | 单步执行调试程序，不会直接执行函数                      |</span><br><span class="line">    | next               | 单步执行调试程序，会直接执行函数                        |</span><br><span class="line">    | backtrace          | 显示所有的调用栈帧。该命令可用来显示函数的调用顺序      |</span><br><span class="line">    | where continue     | 继续执行正在调试的程序                                  |</span><br><span class="line">    | display EXPR       | 每次程序停止后显示表达式的值,表达式由程序定义的变量组成 |</span><br><span class="line">    | file FILENAME      | 装载指定的可执行文件进行调试                            |</span><br><span class="line">    | help CMDNAME       | 显示指定调试命令的帮助信息                              |</span><br><span class="line">    | info break         | 显示当前断点列表，包括到达断点处的次数等                |</span><br><span class="line">    | info files         | 显示被调试文件的详细信息                                |</span><br><span class="line">    | info func          | 显示被调试程序的所有函数名称                            |</span><br><span class="line">    | info prog          | 显示被调试程序的执行状态                                |</span><br><span class="line">    | info local         | 显示被调试程序当前函数中的局部变量信息                  |</span><br><span class="line">    | info var           | 显示被调试程序的所有全局和静态变量名称                  |</span><br><span class="line">    | kill               | 终止正在被调试的程序                                    |</span><br><span class="line">    | list               | 显示被调试程序的源代码                                  |</span><br><span class="line">    | quit               | 退出 gdb                                                |</span><br><span class="line"></span><br><span class="line">## Eclipse + CDT 下载安装</span><br><span class="line"></span><br><span class="line">[参考博客](https://blog.csdn.net/qq_42824983/article/details/114671702)</span><br><span class="line"></span><br><span class="line">* JDK: 是 Java 语言的软件开发包，包含了 Java 的运行环境</span><br><span class="line">* Eclipse ：运行依赖于 JDK</span><br><span class="line">* CDT：C/C++ Developing Tools</span><br><span class="line">* </span><br><span class="line"></span><br><span class="line"># 4 基于硬件模拟器实现源码级调试</span><br><span class="line"></span><br><span class="line">## 4.1 安装硬件模拟器 QEMU</span><br><span class="line"></span><br><span class="line">* 用于模拟一台 X86 计算机，让 uCore 运行在 QEMU 上</span><br><span class="line">* 直接使用 Ubuntu 中提供的 QEMU</span><br><span class="line">  * `sudo apt-gett install qemu-system`</span><br><span class="line"></span><br><span class="line">## 4.2 Linux 环境下的源码级安装 QEMU</span><br><span class="line"></span><br><span class="line">[参考博客](https://blog.csdn.net/wxh0000mm/article/details/90056912?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_baidulandingword-4&amp;spm=1001.2101.3001.4242)</span><br><span class="line"></span><br><span class="line">* 安装时遇到的问题：</span><br><span class="line">  * analysis: 未安装到默认路径</span><br><span class="line">  * problem;输入 `qemu` 无反应</span><br><span class="line">  * solution：[参考博客](https://blog.csdn.net/u013045749/article/details/53575639)</span><br><span class="line">  * 若输入 `qemu-system-x86_64说明安装成功，需要对其进行链接：`sudo ln -s /usr/bin/qumu-system-x86_64 /usr/bin/qemu`</span><br><span class="line"></span><br><span class="line">## 4.3 使用 QEMU</span><br><span class="line"></span><br><span class="line">### 4.3.1 运行参数</span><br><span class="line"></span><br><span class="line">* 默认安装路径：`/usr/local/bin`</span><br><span class="line">* 运行命令：`qemu`</span><br><span class="line">* qemu 运行多参数格式 `qemu [options] [disk_image]`</span><br><span class="line"></span><br><span class="line">  * disk_image：硬盘镜像文件</span><br><span class="line">* 部分参数：</span><br><span class="line"></span><br><span class="line">  * ```</span><br><span class="line">    `-hda file&#x27;        `-hdb file&#x27; `-hdc file&#x27; `-hdd file&#x27;</span><br><span class="line">     使用 file  作为硬盘0、1、2、3镜像。</span><br><span class="line">    `-fda file&#x27;  `-fdb file&#x27;</span><br><span class="line">     使用 file  作为软盘镜像，可以使用 /dev/fd0 作为 file 来使用主机软盘。</span><br><span class="line">    `-cdrom file&#x27;</span><br><span class="line">     使用 file  作为光盘镜像，可以使用 /dev/cdrom 作为 file 来使用主机 cd-rom。</span><br><span class="line">    `-boot [a|c|d]&#x27;</span><br><span class="line">     从软盘(a)、光盘(c)、硬盘启动(d)，默认硬盘启动。</span><br><span class="line">    `-snapshot&#x27;</span><br><span class="line">     写入临时文件而不写回磁盘镜像，可以使用 C-a s 来强制写回。</span><br><span class="line">    `-m megs&#x27;</span><br><span class="line">     设置虚拟内存为 msg M字节，默认为 128M 字节。</span><br><span class="line">    `-smp n&#x27;</span><br><span class="line">     设置为有 n 个 CPU 的 SMP 系统。以 PC 为目标机，最多支持 255 个 CPU。</span><br><span class="line">    `-nographic&#x27;</span><br><span class="line">     禁止使用图形输出。</span><br><span class="line">    其他：</span><br><span class="line">     可用的主机设备 dev 例如：</span><br><span class="line">         vc</span><br><span class="line">             虚拟终端。</span><br><span class="line">         null</span><br><span class="line">             空设备</span><br><span class="line">         /dev/XXX</span><br><span class="line">             使用主机的 tty。</span><br><span class="line">         file: filename</span><br><span class="line">             将输出写入到文件 filename 中。</span><br><span class="line">         stdio</span><br><span class="line">             标准输入/输出。</span><br><span class="line">         pipe：pipename</span><br><span class="line">             命令管道 pipename。</span><br><span class="line">         等。</span><br><span class="line">     使用 dev 设备的命令如：</span><br><span class="line">         `-serial dev&#x27;</span><br><span class="line">             重定向虚拟串口到主机设备 dev 中。</span><br><span class="line">         `-parallel dev&#x27;</span><br><span class="line">             重定向虚拟并口到主机设备 dev 中。</span><br><span class="line">         `-monitor dev&#x27;</span><br><span class="line">             重定向 monitor 到主机设备 dev 中。</span><br><span class="line">     其他参数：</span><br><span class="line">         `-s&#x27;</span><br><span class="line">             等待 gdb 连接到端口 1234。</span><br><span class="line">         `-p port&#x27;</span><br><span class="line">             改变 gdb 连接端口到 port。</span><br><span class="line">         `-S&#x27;</span><br><span class="line">             在启动时不启动 CPU， 需要在 monitor 中输入 &#x27;c&#x27;，才能让qemu继续模拟工作。</span><br><span class="line">         `-d&#x27;</span><br><span class="line">             输出日志到 qemu.log 文件。</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>将用到的命令：</p>
<ul>
<li><code>qemu -hda ucore.img -parallel stdip</code>: 使得ucore在qemu模拟的 x86 硬件环境中执行</li>
<li><code>qemu -S -s -hda ucore.img -monitor stdio</code>: 用于与 gdb 配合进行源码调试</li>
</ul>
</li>
</ul>
<h4 id="常用调试命令"><a href="#常用调试命令" class="headerlink" title="常用调试命令"></a>常用调试命令</h4><ul>
<li><p>qemu 中 monitor 的常用命令：</p>
<ul>
<li><table>
<thead>
<tr>
<th>help</th>
<th>查看 qemu 帮助，显示所有支持的命令。</th>
</tr>
</thead>
<tbody><tr>
<td>q|quit|exit</td>
<td>退出 qemu。</td>
</tr>
<tr>
<td>stop</td>
<td>停止 qemu。</td>
</tr>
<tr>
<td>c|cont|continue</td>
<td>连续执行。</td>
</tr>
<tr>
<td>x /fmt addr xp /fmt addr</td>
<td>显示内存内容，其中 ‘x’ 为虚地址，’xp’ 为实地址。 参数 /fmt i 表示反汇编，缺省参数为前一次参数。</td>
</tr>
<tr>
<td>p|print’</td>
<td>计算表达式值并显示，例如 $reg 表示寄存器结果。</td>
</tr>
<tr>
<td>memsave addr size file pmemsave addr size file</td>
<td>将内存保存到文件，memsave 为虚地址，pmemsave 为实地址。</td>
</tr>
<tr>
<td>breakpoint 相关：</td>
<td>设置、查看以及删除 breakpoint，pc执行到 breakpoint，qemu 停止。（暂时没有此功能）</td>
</tr>
<tr>
<td>watchpoint 相关：</td>
<td>设置、查看以及删除 watchpoint, 当 watchpoint 地址内容被修改，停止。（暂时没有此功能）</td>
</tr>
<tr>
<td>s|step</td>
<td>单步一条指令，能够跳过断点执行。</td>
</tr>
<tr>
<td>r|registers</td>
<td>显示全部寄存器内容。</td>
</tr>
<tr>
<td>info 相关操作</td>
<td>查询 qemu 支持的关于系统状态信息的操作。</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p><code>single arg</code>: arg为参数，设置单步标志命令</p>
<ul>
<li><code>single on</code>: 允许单步<ul>
<li>在此情况下使用 <code>cont</code> 进行单步操作</li>
</ul>
</li>
<li><code>single off</code>: 禁止单步</li>
</ul>
</li>
</ul>
<h2 id="4-4-结合-gdb-和-qemu-源码级调试-uCore"><a href="#4-4-结合-gdb-和-qemu-源码级调试-uCore" class="headerlink" title="4.4 结合 gdb 和 qemu 源码级调试 uCore"></a>4.4 结合 gdb 和 qemu 源码级调试 uCore</h2><h3 id="编译可调式的目标文件"><a href="#编译可调式的目标文件" class="headerlink" title="编译可调式的目标文件"></a>编译可调式的目标文件</h3><ul>
<li>需要在使用 gcc 编译源文件时，添加参数 -g</li>
<li>这样编译出来的目标文件中才会包含可以用于 gdb 调试的相关符号信息</li>
</ul>
<h3 id="ucore-代码编译"><a href="#ucore-代码编译" class="headerlink" title="ucore 代码编译"></a>ucore 代码编译</h3><ul>
<li>编译过程：解压缩后的 ucore 源码包中使用 make 命令<ul>
<li>将生成一些列目标文件</li>
<li>例如 lab1：<code>[]:~/lab1$ make</code><ul>
<li>ucore.img: 被qemu访问过的虚拟硬盘文件</li>
<li>kernel: ELF 格式的 toy ucore kernel 执行文件，被嵌入到了 ucore.img 中</li>
<li>bootblock：虚拟的硬盘主引导扇区（512字节），包含了 bootloader 执行代码，被嵌入到了 ucore.img 中</li>
<li>sign：外部执行程序，用来生成虚拟的硬盘主引导扇区</li>
</ul>
</li>
</ul>
</li>
<li>保存修改:<ul>
<li>使用 diff 命令对修改后的 ucore 代码 和 ucore 源码进行比较，比较之前使用 make clean 清除掉不必要文件</li>
</ul>
</li>
<li>应用修改：</li>
</ul>
<h3 id="使用远程调试"><a href="#使用远程调试" class="headerlink" title="使用远程调试"></a>使用远程调试</h3><ul>
<li><p>与 qemu 配合进行源代码级别的调试，需要先让 qemu 进入等待 gdb 调试器的接入并且还不能让 qemu 的CPU执行</p>
<ul>
<li>因此启动 qemu 时，需要使用 -S -s</li>
<li><code>qemu -S -s</code>：qemu 中的CPU并不会马上执行</li>
</ul>
</li>
<li><p>然后启动 gdb ，<code>target remote 127.0.0.1:1234</code> 连接到qemu</p>
</li>
<li><p><code>c</code>: qemu 继续执行</p>
</li>
<li><p><strong>遇到的问题</strong>：<img src="E:\LearningNotes\TH操作系统\操作系统实验\lab0.assets\image-20210403211514163.png" alt="image-20210403211514163"></p>
<ul>
<li>analysis：</li>
<li>solution：</li>
</ul>
</li>
<li><p>为了使得 gdb 获知符号信息，需要指定调试目标文件，gdb 中 <code>file ./bin/kernel</code></p>
<ul>
<li>gdb 便可载入这个文件中的符号信息</li>
</ul>
</li>
<li><p>遇到的问题：</p>
</li>
<li><p>通过 gdb 可以对 ucore 代码进行调试</p>
</li>
<li><p>例如： 调试memset函数：</p>
<ol>
<li>运行 <code>qemu -S -s -hda ./bin/ucore.img -monitor stdio</code></li>
<li>运行 gdb 并与 qemu 进行连接</li>
<li>设置断点并执行</li>
<li>qemu 单步调试</li>
</ol>
</li>
</ul>
<h3 id="使用-gdb-配置文件"><a href="#使用-gdb-配置文件" class="headerlink" title="使用 gdb 配置文件"></a>使用 gdb 配置文件</h3><h3 id="加载调试目标"><a href="#加载调试目标" class="headerlink" title="加载调试目标"></a>加载调试目标</h3><ul>
<li>因为在指定了执行文件时就已经加载了文件中包含的调试信息，因此不用在使用 gdb 命令专门加载</li>
<li>但是在使用 qemu 进行远程调试的时候，我们必须手动加载符号表，即 <code>file</code></li>
</ul>
<h3 id="设定调试目标架构"><a href="#设定调试目标架构" class="headerlink" title="设定调试目标架构"></a>设定调试目标架构</h3><ul>
<li>在调试的时候，若需要调试不是 i386 保护模式代码，比如8086实模式代码，需要设定当前使用的架构：<code>(gdb) set arch i8086</code></li>
<li></li>
</ul>
<h1 id="5-了解处理器硬件"><a href="#5-了解处理器硬件" class="headerlink" title="5 了解处理器硬件"></a>5 了解处理器硬件</h1><ul>
<li>了解处理器体系结构（了解硬件对 uCore 的影响）和机器指令集（读懂 uCore 的汇编）</li>
<li>uCore 目前支持的硬件环境是基于Intel 80386以上的计算机系统</li>
</ul>
<h2 id="5-1-Intel-80386-运行模式"><a href="#5-1-Intel-80386-运行模式" class="headerlink" title="5.1 Intel 80386 运行模式"></a>5.1 Intel 80386 运行模式</h2><ul>
<li>一般CPU 只有一种运行模式，<ul>
<li>能够支持多个程序在各自独立的内存空间中并发执行，</li>
<li>且有用户特权级和内核特权级的区分，使得一般用户不能破坏操作系统内核和执行特权级指令</li>
</ul>
</li>
<li>80386 处理器有四种运行模式<ul>
<li>实模式</li>
<li>保护模式</li>
<li>SMM 模式</li>
<li>虚拟8086 模式</li>
</ul>
</li>
<li><strong>实模式</strong><ul>
<li>个人计算机早期8086处理器采用的一种简单运行模式</li>
<li>加电启动后处于实模式运行状态</li>
<li>实模式状态下，软件<strong>可访问的物理内存地址空间不能超过1 MB</strong>，且无法发挥 Intel 80386以上级别<strong>32位 CPU 的4 GB 内存管理能力</strong></li>
<li>实模式将整个物理内存看成分段区域，程序代码和数据位于不同区域</li>
<li><strong>操作系统和用户程序未区别对待</strong>，每一个指针都指向实际的物理地址</li>
<li>注意：若用户程序的一个指针指向了操作系统区域或者其他用户程序区域，并修改，后果不堪设想</li>
</ul>
</li>
</ul>
<blockquote>
<p>对于ucore无必要涉及</p>
</blockquote>
<ul>
<li><strong>保护模式</strong><ul>
<li><strong>主要目标</strong>是确保应用程序无法对操作系统进行破坏</li>
<li>实际上，80386就是通过在<strong>实模式</strong>下初始化<strong>控制寄存器</strong>（如GDTR，LDTR，IDTR与TR等管理寄存器）以及<strong>页表</strong>，然后再通过设置<strong>CR0寄存器</strong>使其中的<strong>保护模式</strong> <strong>使能位置位</strong>，从而进入到80386的保护模式</li>
<li>当80386工作在<strong>保护模式</strong>下的时候，其所有的<strong>32根地址线</strong>都可供寻址，物理寻址空间高达4 GB</li>
<li>在保护模式下，支持<strong>内存分页机制</strong>，提供了<strong>对虚拟内存的良好支持</strong></li>
<li><strong>保护模式</strong>下80386支持<strong>多任务</strong>，还支持<strong>优先级机制</strong>，<strong>不同的程序可以运行在不同的特权级上</strong><ul>
<li>特权级一共分0～3四个级别，操作系统运行在最高的特权级0上，应用程序则运行在比较低的级别上；</li>
<li>配合良好的检查机制后，既可以在任务间<strong>实现数据的安全共享</strong>也可以很好地<strong>隔离各个任务</strong>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="5-2-Intel-80386内存架构"><a href="#5-2-Intel-80386内存架构" class="headerlink" title="5.2 Intel 80386内存架构"></a>5.2 Intel 80386内存架构</h2><ul>
<li><strong>32</strong> 位的处理器：<strong>可以寻址的物理内存地址空间</strong>为 2^32 = 4 G 字节</li>
<li>三个地址空间概念：<ul>
<li><strong>物理地址</strong><ul>
<li>处理器提交到总线上用于访问计算机系统中的内存和外设的<strong>最终地址</strong></li>
<li>一个计算机系统中只有一个物理地址空间</li>
</ul>
</li>
<li><strong>线性地址</strong><ul>
<li>80386处理器通过<strong>段（Segment）机制</strong>控制下的形成的地址空间</li>
<li><strong>段机制</strong><ul>
<li>在操作系统的管理下，<strong>每个运行</strong>的应用程序有<strong>相对独立</strong>的一个或多个内存空间段，每个段有各自的起始地址和长度属性，大小不固定，这样可让多个运行的应用程序之间<strong>相互隔离</strong>，实现<strong>对地址空间的保护</strong>。</li>
<li>在操作系统完成对80386处理器段机制的<strong>初始化和配置</strong>（<em>主要是需要操作系统通过特定的指令和操作建立<strong>全局描述符表</strong>，完成虚拟地址与线性地址的映射关系</em>）后，80386处理器的<strong>段管理功能单元</strong>负责把虚拟地址转换成线性地址</li>
</ul>
</li>
<li><strong>页机制</strong><ul>
<li><strong>页机制</strong>，每个页的大小是固定的<strong>（4 KB）</strong>，可完成<strong>对内存单元的安全保护，隔离</strong>，可有效<strong>支持大量应用程序分散的使用大内存</strong>的情况</li>
<li>在操作系统完成对80386处理器页机制的<strong>初始化和配置</strong>（<em>主要是需要操作系统通过特定的指令和操作建立页表，完成虚拟地址与线性地址的映射关系</em>）后，应用程序看到的<strong>逻辑地址先被处理器中的段管理功能单元转换为线性地址</strong>，然后再通过80386<strong>处理器中的页管理功能单元把线性地址转换成物理地址</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><strong>逻辑地址</strong></li>
</ul>
</li>
</ul>
<blockquote>
<p>页机制和段机制有一定程度的功能重复，但Intel公司为了向下兼容，使得两者一直共存</p>
</blockquote>
<ul>
<li>分段机制启动，分页机制为启动时：逻辑地址——<strong>段机制处理</strong>——&gt;线性地址==物理地址</li>
<li>两个机制都启动时：逻辑地址——<strong>段机制处理</strong>——&gt;线性地址——<strong>页机制处理</strong>——&gt;物理地址</li>
</ul>
<h2 id="5-3-Intel-80386-寄存器"><a href="#5-3-Intel-80386-寄存器" class="headerlink" title="5.3 Intel 80386 寄存器"></a>5.3 Intel 80386 寄存器</h2><ul>
<li><p>80386 寄存器可分为8类：宽度都为 32 位</p>
<ol>
<li><p><strong>通用寄存器</strong>（General Register）</p>
<ul>
<li><p>EAX（<strong>累加器</strong>）/EBX（<strong>基址寄存器</strong>）/ECX（<strong>计数器</strong>）/EDX（<strong>数据寄存器</strong>）/</p>
<p>ESI（<strong>源地址指针寄存器</strong>）/EDI（<strong>目的地址指针寄存器</strong>）/ESP（<strong>堆栈指针寄存器</strong>）/EBP（<strong>基址指针寄存器</strong>）</p>
<ul>
<li>低十六位：AX/BX/CX/DX/SI/DI/SP/BP<ul>
<li>可以单独存取AX,BX,CX,DX 的高八位和低八位</li>
<li>AH,AL/BH,BL/CH,CL/DH,DL</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>段寄存器</strong>（Segment Register）: 都是 16 位的</p>
<ul>
<li>CS,  <strong>代码段</strong>（Code Segment）</li>
<li>DS, <strong>数据段</strong>（Data Segment）</li>
<li>ES, <strong>附加数据段</strong>（Extra Segment）</li>
<li>SS, <strong>堆栈段</strong>（Stack Segment）</li>
<li>FS, <strong>附加段</strong></li>
<li>GS, <strong>附加段</strong></li>
</ul>
</li>
<li><p><strong>指令指针寄存器</strong>（Instruction Pointer）</p>
<ul>
<li>EIP 的低 16 位就是8086的IP，他存储的是下一条要执行指令的内存地址，在分段地址转换中，表示指令的段内偏移地址</li>
</ul>
</li>
<li><p><strong>标志寄存器</strong>（Flag Register）：</p>
<ul>
<li>EFLAGS，和8086的16位标志寄存器相比，增加了4个控制位，者20位控制/标志位：<ul>
<li><img src="https://objectkuan.gitbooks.io/ucore-docs/content/lab0_figs/image006.png" alt="状态寄存器"></li>
<li>控制/标志位含义：</li>
</ul>
</li>
</ul>
</li>
<li><p>系统地址寄存器</p>
</li>
<li><p>控制寄存器</p>
</li>
<li><p>调试寄存器</p>
</li>
<li><p>测试寄存器</p>
</li>
</ol>
</li>
</ul>
<h1 id="6-了解-uCore-编程方法和通用数据结构"><a href="#6-了解-uCore-编程方法和通用数据结构" class="headerlink" title="6 了解 uCore 编程方法和通用数据结构"></a>6 了解 uCore 编程方法和通用数据结构</h1><h2 id="6-1-面向对象编程方法"><a href="#6-1-面向对象编程方法" class="headerlink" title="6.1 面向对象编程方法"></a>6.1 面向对象编程方法</h2><ul>
<li>uCore 设计中采用了一定的面向对象编程方法</li>
<li>需要注意，我们并不需要用 C 语言模拟出一个常见C++编译器已经实现的对象模型</li>
<li>uCore 的面向对象编程方法，目前主要是采用了类似 C++ 的接口（interface）<ul>
<li>即是让实现细节不同的某类内核子系统（比如物理内存分配器、调度器，文件系统等）有共同的操作方式</li>
<li>虽然内存子系统的实现千差万别，但它的访问接口是不变的</li>
</ul>
</li>
<li>接口在 C 语言中，表现为一组函数指针的集合</li>
<li>接口设计的难点是如何找出各种内核子系统的共性访问/操作模式，从而可以根据访问模式提取出函数指针列表</li>
</ul>
<h2 id="6-2-通用数据结构双向循环链表"><a href="#6-2-通用数据结构双向循环链表" class="headerlink" title="6.2 通用数据结构双向循环链表"></a>6.2 通用数据结构双向循环链表</h2><h3 id="6-2-1-双向循环链表"><a href="#6-2-1-双向循环链表" class="headerlink" title="6.2.1 双向循环链表"></a>6.2.1 双向循环链表</h3><ul>
<li><p>数据结构课程中</p>
<ul>
<li>专门的成员变量 data</li>
<li>两个指向该类型的指针 next 和 prev</li>
<li>```C<br>typedef struct foo {<pre><code>ElemType data;
struct foo *prev;
struct foo *next;
</code></pre>
} foo_t;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">* 特点：</span><br><span class="line"></span><br><span class="line">  * 尾节点的后继指向首节点</span><br><span class="line">  * ![双向循环链表](https://objectkuan.gitbooks.io/ucore-docs/content/lab0_figs/image007.png)</span><br><span class="line">* 潜在问题：由于每种特定数据结构类型不一致，需要为每种特定数据结构类型 定义针对这个数据结构的特定链表插入、删除等操作</span><br><span class="line">* 在uCore中，借鉴了 Linux 内核的双向链表实现：</span><br><span class="line"></span><br><span class="line">  * ```C</span><br><span class="line">    struct list_entry_t &#123;</span><br><span class="line">        struct list_entry_t *prev, *next;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></li>
<li>链表节点 list_entry_t 没有包含数据域，而是<strong>在具体的数据结构中包含该链表节点</strong></li>
</ul>
</li>
<li><p>例如 lab 2 中的空闲内存块列表，<strong>空闲块链表的头指针</strong>定义为：</p>
<ul>
<li><p>```C<br>/* free_area_t - maintains a doubly linked list to record free (unused) pages */</p>
<p>typedef struct {</p>
<pre><code>list_entry_t free_list;         // the list header
unsigned int nr_free;           // # of free pages in this free list
</code></pre>
<p>} free_area_t;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">* 每一个**空闲块链表节点**定义为：</span><br><span class="line"></span><br><span class="line">  * ```C</span><br><span class="line">    /* *</span><br><span class="line">     * struct Page - Page descriptor structures. Each Page describes one</span><br><span class="line">     * physical page. In kern/mm/pmm.h, you can find lots of useful functions</span><br><span class="line">     * that convert Page to other data types, such as phyical address.</span><br><span class="line">     * */</span><br><span class="line">    struct Page &#123;</span><br><span class="line">        atomic_t ref;          // page frame&#x27;s reference counter</span><br><span class="line">        ……</span><br><span class="line">        list_entry_t page_link;         // free list link</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><img src="https://objectkuan.gitbooks.io/ucore-docs/content/lab0_figs/image008.png" alt="空闲块双向循环链表" style="zoom:150%;" /></li>
<li><p>通用双向循环链表结构</p>
<ul>
<li>避免了为每个特定数据结构类型 定义针对这个数据结构的特定链表的麻烦，</li>
<li>让所有的特定数据结构共享通用的链表操作函数</li>
</ul>
</li>
<li><p>通用双向循环链表函数定义：</p>
<ul>
<li><p>初始化：</p>
<ul>
<li><p>uCore 只定义了链表节点，没有专门定义链表头</p>
</li>
<li><p>内联函数（<strong>inline function</strong>）list_init:</p>
<ul>
<li>```C<br>static inline void<br>list_init(list_entry_t *elm) {<pre><code>elm-&gt;prev = elm-&gt;next = elm;
</code></pre>
}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  * 调用 list_init(free_area.free_list) ，</span><br><span class="line"></span><br><span class="line">    * 声明了一个名为 free_area.free_list 的链表头</span><br><span class="line">    * 空链表，链表头的 next 和 prev 都初始化指向自己</span><br><span class="line">    * 可以用next 是否指向自己判断是否为空</span><br><span class="line">* 插入：</span><br><span class="line"></span><br><span class="line">  * 表头插入（**list_add_after**）</span><br><span class="line">  * 表尾插入（**list_add_before**）</span><br><span class="line">  * 由于双向循环链表的链表头 next 和 prev 分别指向链表中第一个和最后一个节点，两者实现区别并不大</span><br><span class="line">  * uCore</span><br><span class="line"></span><br><span class="line">    * **list_add(elm, listelm, listelm-&gt;next)** 实现表头插入</span><br><span class="line">    * **list_add(elm, listelm-&gt;prev, listelm)** 实现表尾插入</span><br><span class="line">  * list_add:</span><br><span class="line"></span><br><span class="line">    * ```C</span><br><span class="line">      static inline void</span><br><span class="line">      __list_add(list_entry_t *elm, list_entry_t *prev, list_entry_t *next) &#123;</span><br><span class="line">          prev-&gt;next = next-&gt;prev = elm;</span><br><span class="line">          elm-&gt;next = next;</span><br><span class="line">          elm-&gt;prev = prev;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>表头插入：插入在listelm 后，即插在链表的最前位置</p>
</li>
<li><p>表尾插入：插入在 listelm-&gt;prev 之后，即插入在链表最后位置</p>
</li>
</ul>
</li>
<li><p>删除</p>
<ul>
<li>删除空闲块链表中的 Page 结构的链表节点时，调用 内联函数 list_del , list_del 进一步调用了_list_del 完成具体的删除操作</li>
<li>```C<br>static inline void<br>list_del(list_entry_t *listelm) {<pre><code>__list_del(listelm-&gt;prev, listelm-&gt;next);
</code></pre>
}<br>static inline void<br>__list_del(list_entry_t *prev, list_entry_t *next) {<pre><code>prev-&gt;next = next;
next-&gt;prev = prev;
</code></pre>
}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  * 如果要确保 被删除的节点 listelm 不在指向链表中其他节点，可以通过调用 list_init 来把 listelm 的pre、next 指针分别指向自身——可以通过 list_del_int 完成</span><br><span class="line">* 访问链表节点所在的宿主数据结构</span><br><span class="line"></span><br><span class="line">  * list_entry_t 通用双向循环链表 仅仅保存了某特定数据结构中链表节点成员变量的地址</span><br><span class="line">  * 如何通过这个链表节点成员变量访问到他的所有者（某特定数据结构的变量）</span><br><span class="line">  * Linux 提供了针对该数据结构 XXX 的 leXXX 的宏</span><br><span class="line"></span><br><span class="line">    * le 为 list entry 简称，是指向数据结构 XXX 中 list_entry_t 成员变量的指针，即存储在双向链表中的结点地址值</span><br><span class="line">    * member 是指 XXX数据类型中包含的链表节点的成员变量</span><br><span class="line">  * ```C</span><br><span class="line">    //free_area是空闲块管理结构，free_area.free_list是空闲块链表头</span><br><span class="line">    free_area_t free_area;</span><br><span class="line">    list_entry_t * le = &amp;free_area.free_list;  //le是空闲块链表头指针</span><br><span class="line">    while((le=list_next(le)) != &amp;free_area.free_list) &#123; //从第一个节点开始遍历</span><br><span class="line">        struct Page *p = le2page(le, page_link); //获取节点所在基于Page数据结构的变量</span><br><span class="line">        ……</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>le2page 宏：</p>
<ul>
<li><pre><code class="C">// convert list entry to page
#define le2page(le, member)                 \
to_struct((le), struct Page, member)
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="https://zihao256.github.io">zihao</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://zihao256.github.io/p/20b5d973.html">https://zihao256.github.io/p/20b5d973.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/ZiHao256/ZiHao256.github.io/hexo/images/wallhaven13.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/p/c6746613.html"><img class="prev-cover" src="https://raw.githubusercontent.com/ZiHao256/ZiHao256.github.io/hexo/images/wallhaven-1pr8q9.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">5 Array</div></div></a></div><div class="next-post pull-right"><a href="/p/9de48019.html"><img class="next-cover" src="https://raw.githubusercontent.com/ZiHao256/ZiHao256.github.io/hexo/images/wallhaven2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">4 流程控制</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/p/4b288195.html" title="专题四设备驱动"><img class="cover" src="https://raw.githubusercontent.com/ZiHao256/ZiHao256.github.io/hexo/images/wallhaven9.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-19</div><div class="title">专题四设备驱动</div></div></a></div><div><a href="/p/69488089.html" title="专题三内核模块"><img class="cover" src="https://raw.githubusercontent.com/ZiHao256/ZiHao256.github.io/hexo/images/wallhaven1.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-19</div><div class="title">专题三内核模块</div></div></a></div><div><a href="/p/6e049acd.html" title="专题二系统调用"><img class="cover" src="https://raw.githubusercontent.com/ZiHao256/ZiHao256.github.io/hexo/images/wallhaven-4ggvml.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-19</div><div class="title">专题二系统调用</div></div></a></div><div><a href="/p/d1d6ca89.html" title="专题一内核编译"><img class="cover" src="https://raw.githubusercontent.com/ZiHao256/ZiHao256.github.io/hexo/images/joseph-barrientos-oQl0eVYd_n8-unsplash.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-19</div><div class="title">专题一内核编译</div></div></a></div><div><a href="/p/a3ec7244.html" title="创建进程、子进程和进程间通信"><img class="cover" src="https://raw.githubusercontent.com/ZiHao256/ZiHao256.github.io/hexo/images/steven-kamenar-MMJx78V7xS8-unsplash.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-19</div><div class="title">创建进程、子进程和进程间通信</div></div></a></div><div><a href="/p/bf869091.html" title="Lab1"><img class="cover" src="https://raw.githubusercontent.com/ZiHao256/ZiHao256.github.io/hexo/images/wallhaven-4ggvml.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-07</div><div class="title">Lab1</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://github.com/ZiHao256/ZiHao256.github.io/blob/hexo/images/stitch.JPG?raw=true" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">zihao</div><div class="author-info__description">Why be afraid of the infinity of truth? Joy resides in every step of growth.</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">60</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">39</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">16</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ZiHao256"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/ZiHao256" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS链接"><i class="fa fa-rss"></i></a><a class="social-icon" href="mailto:zihao626@gmail.com" target="_blank" title="gmail"><i class="fa-brands fa-google"></i></a><a class="social-icon" href="mailto:zh_ma@stu.xidian.edu.cn" target="_blank" title="xdu-mail"><i class="fa fa-graduation-cap"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">keep moving in 2023</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Lab-0"><span class="toc-text">Lab 0</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E5%AE%89%E8%A3%85%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="toc-text">1 安装一个操作系统的开发过程：</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83"><span class="toc-text">2 实验环境</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E4%BD%BF%E7%94%A8-Linux-%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83"><span class="toc-text">2.1 使用 Linux 实验环境</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E5%8F%AF%E8%83%BD%E7%94%A8%E5%88%B0%E7%9A%84%E8%BD%AF%E4%BB%B6"><span class="toc-text">2.2 可能用到的软件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-5-GCC-%E6%89%A9%E5%B1%95%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96"><span class="toc-text">3.1.5 GCC 扩展内联汇编</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E6%A8%A1%E6%9D%BF%EF%BC%88assembler-template%EF%BC%89"><span class="toc-text">汇编模板（assembler template）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E6%95%B0%EF%BC%88Operands%EF%BC%89"><span class="toc-text">操作数（Operands）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E8%B0%83%E8%AF%95%E5%91%BD%E4%BB%A4"><span class="toc-text">常用调试命令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E7%BB%93%E5%90%88-gdb-%E5%92%8C-qemu-%E6%BA%90%E7%A0%81%E7%BA%A7%E8%B0%83%E8%AF%95-uCore"><span class="toc-text">4.4 结合 gdb 和 qemu 源码级调试 uCore</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%8F%AF%E8%B0%83%E5%BC%8F%E7%9A%84%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6"><span class="toc-text">编译可调式的目标文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ucore-%E4%BB%A3%E7%A0%81%E7%BC%96%E8%AF%91"><span class="toc-text">ucore 代码编译</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95"><span class="toc-text">使用远程调试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-gdb-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-text">使用 gdb 配置文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E8%B0%83%E8%AF%95%E7%9B%AE%E6%A0%87"><span class="toc-text">加载调试目标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%AE%9A%E8%B0%83%E8%AF%95%E7%9B%AE%E6%A0%87%E6%9E%B6%E6%9E%84"><span class="toc-text">设定调试目标架构</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E4%BA%86%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8%E7%A1%AC%E4%BB%B6"><span class="toc-text">5 了解处理器硬件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-Intel-80386-%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F"><span class="toc-text">5.1 Intel 80386 运行模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-Intel-80386%E5%86%85%E5%AD%98%E6%9E%B6%E6%9E%84"><span class="toc-text">5.2 Intel 80386内存架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-Intel-80386-%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-text">5.3 Intel 80386 寄存器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E4%BA%86%E8%A7%A3-uCore-%E7%BC%96%E7%A8%8B%E6%96%B9%E6%B3%95%E5%92%8C%E9%80%9A%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">6 了解 uCore 编程方法和通用数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E6%96%B9%E6%B3%95"><span class="toc-text">6.1 面向对象编程方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E9%80%9A%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="toc-text">6.2 通用数据结构双向循环链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-1-%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="toc-text">6.2.1 双向循环链表</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/p/1c228cd6.html" title="Project#1: Buffer Pool"><img src="https://raw.githubusercontent.com/ZiHao256/ZiHao256.github.io/hexo/images/wallhaven6.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Project#1: Buffer Pool"/></a><div class="content"><a class="title" href="/p/1c228cd6.html" title="Project#1: Buffer Pool">Project#1: Buffer Pool</a><time datetime="2023-10-03T05:01:58.000Z" title="Created 2023-10-03 13:01:58">2023-10-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/p/6fa5e9a2.html" title="Project#0: C++ Primer"><img src="https://raw.githubusercontent.com/ZiHao256/ZiHao256.github.io/hexo/images/wallhaven1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Project#0: C++ Primer"/></a><div class="content"><a class="title" href="/p/6fa5e9a2.html" title="Project#0: C++ Primer">Project#0: C++ Primer</a><time datetime="2023-10-01T06:44:47.000Z" title="Created 2023-10-01 14:44:47">2023-10-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/p/42c77a0c.html" title="Paper Reading: TECCD: A Tree Embedding Approach for Code Clone Detection"><img src="https://raw.githubusercontent.com/ZiHao256/ZiHao256.github.io/hexo/images/wallhaven7.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Paper Reading: TECCD: A Tree Embedding Approach for Code Clone Detection"/></a><div class="content"><a class="title" href="/p/42c77a0c.html" title="Paper Reading: TECCD: A Tree Embedding Approach for Code Clone Detection">Paper Reading: TECCD: A Tree Embedding Approach for Code Clone Detection</a><time datetime="2023-05-16T06:17:01.000Z" title="Created 2023-05-16 14:17:01">2023-05-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/p/69c3279c.html" title="Git"><img src="https://raw.githubusercontent.com/ZiHao256/ZiHao256.github.io/hexo/images/wallhaven6.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Git"/></a><div class="content"><a class="title" href="/p/69c3279c.html" title="Git">Git</a><time datetime="2023-05-15T13:42:40.000Z" title="Created 2023-05-15 21:42:40">2023-05-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/p/26d71884.html" title="Overleaf"><img src="https://raw.githubusercontent.com/ZiHao256/ZiHao256.github.io/hexo/images/wallhaven5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Overleaf"/></a><div class="content"><a class="title" href="/p/26d71884.html" title="Overleaf">Overleaf</a><time datetime="2023-05-15T11:11:58.000Z" title="Created 2023-05-15 19:11:58">2023-05-15</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://raw.githubusercontent.com/ZiHao256/ZiHao256.github.io/hexo/images/wallhaven13.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2023 By zihao</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://zihao256.github.io/">Blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional Chinese And Simplified Chinese">简</button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function addGitalkSource () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)
}

function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: '3b2ff3959cccdea73272',
      clientSecret: 'ff54cd4f8d455c066e787ca2dc1684a21094e488',
      repo: 'ZiHao256.github.io',
      owner: 'ZiHao256',
      admin: ['ZiHao256'],
      id: 'a5fb8b878c7b2fff8c6565c2bdc04d43',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    addGitalkSource()
    getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !false) {
  if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[image]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[link]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[code]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const findTrueUrl = (array) => {
    Promise.all(array.map(item =>
      fetch(item.url).then(resp => resp.json()).then(data => {
        const urlArray = data.body.match(/(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?/ig)
        if (data.user.login === 'utterances-bot') {
          return urlArray.pop()
        } else {
          return urlArray.shift()
        }
      })
    )).then(res => {
        array = array.map((i,index)=> {
          return {
            ...i,
            url: res[index]
          }
        })

        saveToLocal.set('github-newest-comments', JSON.stringify(array), 10/(60*24))
        generateHtml(array)
    });
  }

  const getComment = () => {
    fetch('https://api.github.com/repos/ZiHao256/ZiHao256.github.io/issues/comments?sort=updated&direction=desc&per_page=6&page=1',{
      "headers": {
        Accept: 'application/vnd.github.v3.html+json'
      }
    })
      .then(response => response.json())
      .then(data => {
        const githubArray = data.map(item => {
          return {
            'avatar': item.user.avatar_url,
            'content': changeContent(item.body_html),
            'nick': item.user.login,
            'url': item.issue_url,
            'date': item.updated_at,
            'githubUrl': item.html_url
          }
        })
        findTrueUrl(githubArray)
      }).catch(e => {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.innerHTML= "Unable to get the data, please make sure the settings are correct."
      })
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }

        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += 'No Comment'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom.innerHTML= result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('github-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><div class="aplayer no-destroy" data-id="6738460302" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true"> </div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="true"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>