/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => AttachmentUploader
});
module.exports = __toCommonJS(main_exports);
var import_child_process = require("child_process");
var import_obsidian2 = require("obsidian");
var import_path = require("path");
var import_util = require("util");

// src/lang/helpers.ts
var import_obsidian = require("obsidian");

// src/lang/locale/en.ts
var en_default = {
  "Upload attachments": "Upload attachments",
  "No local attachment matching the upload conditions was found.": "No local attachment matching the upload conditions was found.",
  "attachments that matched the upload conditions \n Start uploading replacement...": "attachments that matched the upload conditions \n Start uploading replacement...",
  "Uploaded attachment:": "Uploaded attachment:",
  "Replace with:": "Replace with:",
  "Local attachment deleted": "Local attachment deleted",
  "Upload failed:": "Upload failed:",
  "Error message:": "Error message:",
  "Upload command": "Upload command",
  "Upload service": "Upload service",
  "Executed command": "Executed command",
  "The command is executed using the exec method of child_process. %s indicates the path of the file to be uploaded, reserve it. Extract the uploaded link from the shell output after execution,": "The command is executed using the exec method of child_process. %s indicates the path of the file to be uploaded, reserve it. Extract the uploaded link from the shell output after execution,",
  "Test file path": "Test file path",
  "Upload test": "Upload test",
  "Enter the test file path": "Enter the test file path",
  "Upload successful": "Upload successful",
  "Upload failed": "Upload failed",
  "Upload rules": "Upload rules",
  "Attachment format to be uploaded": "Attachment format to be uploaded",
  "The file in the configuration format will be uploaded when the command is executed and the original address will be replaced with the network address. The format will be separated by carriage returns.": "The file in the configuration format will be uploaded when the command is executed and the original address will be replaced with the network address. The format will be separated by carriage returns.",
  "Delete local files after successful upload": "Delete local files after successful upload"
};

// src/lang/locale/zh-cn.ts
var zh_cn_default = {
  "Upload attachments": "\u4E0A\u4F20\u9644\u4EF6",
  "No local attachment matching the upload conditions was found.": "\u672A\u627E\u5230\u7B26\u5408\u4E0A\u4F20\u6761\u4EF6\u672C\u5730\u9644\u4EF6",
  "attachments that meet the upload conditions \n Start uploading replacement...": "\u4E2A\u7B26\u5408\u4E0A\u4F20\u6761\u4EF6\u7684\u9644\u4EF6\n\u5F00\u59CB\u4E0A\u4F20\u66FF\u6362\u2026",
  "Uploaded attachment:": "\u5DF2\u4E0A\u4F20\u9644\u4EF6:",
  "Replace with:": "\u66FF\u6362\u4E3A:",
  "Local attachment deleted": "\u672C\u5730\u9644\u4EF6\u5DF2\u5220\u9664",
  "Upload failed:": "\u4E0A\u4F20\u5931\u8D25:",
  "Error message:": "\u9519\u8BEF\u4FE1\u606F:",
  "Upload command": "\u4E0A\u4F20\u547D\u4EE4",
  "Upload service": "\u4E0A\u4F20\u670D\u52A1",
  "Executed command": "\u6267\u884C\u547D\u4EE4",
  "The command is executed using the exec method of child_process. %s indicates the path of the file to be uploaded, reserve it. Extract the uploaded link from the shell output after execution,": "\u547D\u4EE4\u901A\u8FC7child_process\u7684exec\u65B9\u6CD5\u6267\u884C; %s\u4E3A\u8981\u4E0A\u4F20\u6587\u4EF6\u7684\u8DEF\u5F84,\u8BF7\u4FDD\u7559; \u6267\u884C\u540E\u4ECEshell\u8F93\u51FA\u4E2D\u63D0\u53D6\u4E0A\u4F20\u540E\u7684\u94FE\u63A5",
  "Test file path": "\u6D4B\u8BD5\u6587\u4EF6\u8DEF\u5F84",
  "Upload test": "\u4E0A\u4F20\u6D4B\u8BD5",
  "Enter the test file path": "\u8BF7\u8F93\u5165\u6D4B\u8BD5\u4E0A\u4F20\u6587\u4EF6\u8DEF\u5F84",
  "Upload successful": "\u4E0A\u4F20\u6210\u529F",
  "Upload failed": "\u4E0A\u4F20\u5931\u8D25",
  "Upload rules": "\u4E0A\u4F20\u89C4\u5219",
  "Attachment format to be uploaded": "\u9700\u6C42\u4E0A\u4F20\u9644\u4EF6\u7684\u683C\u5F0F",
  "The file in the configuration format will be uploaded when the command is executed and the original address will be replaced with the network address. The format will be separated by carriage returns.": "\u914D\u7F6E\u5185\u683C\u5F0F\u7684\u6587\u4EF6\uFF0C\u4F1A\u5728\u6267\u884C\u547D\u4EE4\u65F6\u88AB\u4E0A\u4F20\u5E76\u7528\u7F51\u7EDC\u5730\u5740\u66FF\u6362\u539F\u5730\u5740\uFF0C\u683C\u5F0F\u4EE5\u56DE\u8F66\u5206\u5272",
  "Delete local files after successful upload": "\u4E0A\u4F20\u6210\u529F\u540E\u5220\u9664\u672C\u5730\u6587\u4EF6"
};

// src/lang/helpers.ts
var localeMap = {
  en: en_default,
  "zh-cn": zh_cn_default
};
var locale = localeMap[import_obsidian.moment.locale()];
function t(str) {
  return (locale == null ? void 0 : locale[str]) || en_default[str];
}

// src/main.ts
var uploadCommandDict = {
  uPic: "/Applications/uPic.app/Contents/MacOS/uPic -o url -u %s",
  Picsee: "/Applications/Picsee.app/Contents/MacOS/Picsee -u %s",
  custom: ""
};
var DEFAULT_SETTINGS = {
  uploadService: "uPic",
  uploadCommand: uploadCommandDict.uPic,
  uploadFileFormat: ".png\n.jpg\n.jpeg\n.gif\n.webp\n.ico\n.svg\n.bmp",
  testFilePath: "",
  isDeleteSourceFile: false
};
var AttachmentUploader = class extends import_obsidian2.Plugin {
  async onload() {
    await this.loadSettings();
    this.addRibbonIcon("upload", t("Upload attachments"), (evt) => {
      this.uploadEditorAttachment();
    });
    this.addCommand({
      id: "upload-editor-attachments",
      name: "Upload editor attachments",
      editorCallback: () => this.uploadEditorAttachment()
    });
    this.addSettingTab(new SettingTab(this.app, this));
  }
  /**
   * 上传编辑器内符合条件的附件
   */
  uploadEditorAttachment() {
    const activeEditor = this.app.workspace.activeEditor;
    if (activeEditor) {
      const attachments = this.getEditorAttachments(activeEditor);
      new import_obsidian2.Notice(
        attachments.length > 0 ? `${attachments.length} +
					  ${t("attachments that matched the upload conditions \n Start uploading replacement...")}` : `${t("No local attachment matching the upload conditions was found.")}`
      );
      attachments.forEach(async (attachment) => {
        var _a, _b;
        const sourceFile = this.app.vault.getAbstractFileByPath(attachment.inVaultPath);
        const uploadResult = await this.uploadServe(attachment.inSystemPath);
        if (uploadResult.success) {
          (_b = activeEditor == null ? void 0 : activeEditor.editor) == null ? void 0 : _b.setValue(
            (_a = activeEditor == null ? void 0 : activeEditor.editor) == null ? void 0 : _a.getValue().replace(attachment.source, `![${attachment.alt}](${uploadResult.url})`)
          );
          if (this.settings.isDeleteSourceFile && sourceFile) {
            this.app.vault.delete(sourceFile);
          }
          new import_obsidian2.Notice(
            `${t("Uploaded attachment:")}${attachment.inVaultPath}

						 ${t("Replace with:")}${uploadResult.url}

						${this.settings.isDeleteSourceFile && sourceFile ? `${t("Local attachment deleted")}` : ""}`
          );
        } else {
          new import_obsidian2.Notice(
            `${t("Upload failed:")}${attachment.inVaultPath}

${t("Error message:")}
${uploadResult.errorMessage}`
          );
        }
      });
    }
  }
  /**
   * 获取编辑器中的附件信息
   *
   * @param markdownFile - Markdown 文件信息对象
   * @returns 附件数组
   */
  getEditorAttachments(markdownFile) {
    var _a, _b;
    const attachments = [];
    const regex = /!\[(.*?)\]\((.*?)\)/g;
    const matches = (_a = markdownFile == null ? void 0 : markdownFile.editor) == null ? void 0 : _a.getValue().match(regex);
    const vaultSystemPath = ((_b = markdownFile == null ? void 0 : markdownFile.file) == null ? void 0 : _b.vault.adapter).getBasePath();
    if (matches) {
      matches.forEach((match) => {
        var _a2, _b2;
        const attSourcePath = (_a2 = match.match(/\((.*?)\)/)) == null ? void 0 : _a2[1];
        const alt = (_b2 = match.match(/\[(.*?)\]/)) == null ? void 0 : _b2[1];
        if (attSourcePath) {
          const file = (0, import_path.parse)((0, import_obsidian2.normalizePath)(decodeURI(attSourcePath)));
          const searchFile = this.app.vault.getFiles().find((f) => f.name === file.name + file.ext.toLowerCase());
          const attachment = {
            source: match,
            alt: alt ? alt : file.name,
            // 如果有指定 alt 文本，则使用指定的 alt 文本，否则使用文件名称作为 alt 文本
            basename: file.base,
            name: file.name,
            ext: file.ext,
            existenceState: attSourcePath.startsWith("http") ? "network" : searchFile ? "local" : "missing",
            // 图片链接未找到
            inVaultPath: searchFile ? searchFile == null ? void 0 : searchFile.path : (0, import_obsidian2.normalizePath)(attSourcePath),
            // 在 Vault 中找到对应的文件获取其 Vault 路径，否则为绝为原附件路径/图片网络链接
            inSystemPath: searchFile ? encodeURI((0, import_path.join)(vaultSystemPath, searchFile == null ? void 0 : searchFile.path)) : encodeURI((0, import_obsidian2.normalizePath)(attSourcePath))
          };
          if (this.settings.uploadFileFormat.split("\n").includes(attachment.ext.toLowerCase()) && // 检查文件扩展名是否在允许上传的文件格式中
          attachment.existenceState === "local") {
            attachments.push(attachment);
          }
        }
      });
    }
    return attachments;
  }
  /** 上传命令执行后从 shell 输出中提取上传后的链接
   *
   * @param path  要上传的文件在系统内的路径
   */
  async uploadServe(path) {
    const execPromise = (0, import_util.promisify)(import_child_process.exec);
    const command = (0, import_util.format)(this.settings.uploadCommand, path);
    try {
      const { stdout } = await execPromise(command);
      const urlMatch = stdout.match(/\s+(https?:\/\/\S+)/);
      if (urlMatch) {
        const decodeUrl = decodeURIComponent(urlMatch[1]);
        return {
          success: true,
          url: decodeUrl
        };
      }
      return {
        success: false,
        errorMessage: stdout
      };
    } catch (err) {
      const error = err;
      console.error(`err: ${error}`);
      new import_obsidian2.Notice(error.message.toString());
      throw err;
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  onunload() {
  }
};
var SettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: t("Upload command") });
    new import_obsidian2.Setting(containerEl).setName(t("Upload service")).addDropdown((dropdown) => {
      return dropdown.addOptions({
        uPic: "uPic",
        Picsee: "Picsee",
        custom: "custom"
      }).setValue(this.plugin.settings.uploadService).onChange(async (value) => {
        this.plugin.settings.uploadService = value;
        this.plugin.settings.uploadCommand = uploadCommandDict[this.plugin.settings.uploadService];
        this.display();
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian2.Setting(containerEl).setName(t("Executed command")).setDesc(
      `${t(
        "The command is executed using the exec method of child_process. %s indicates the path of the file to be uploaded, reserve it. Extract the uploaded link from the shell output after execution,"
      )}\u2018urlMatch = stdout.match(/s+(https?:/ / S +) /)\u2019`
    ).addTextArea((textArea) => {
      textArea.setValue(uploadCommandDict[this.plugin.settings.uploadService]).onChange(async (value) => {
        this.plugin.settings.uploadCommand = value;
        await this.plugin.saveSettings();
      }).setDisabled(this.plugin.settings.uploadService !== "custom");
      textArea.inputEl.style.height = "80px";
    });
    new import_obsidian2.Setting(containerEl).setName(t("Test file path")).addText((text) => {
      text.onChange(async (value) => {
        this.plugin.settings.testFilePath = value;
        await this.plugin.saveSettings();
      });
      new import_obsidian2.Setting(containerEl).addButton((btn) => {
        btn.setButtonText(t("Upload test")).onClick(async () => {
          if (!this.plugin.settings.testFilePath) {
            new import_obsidian2.Notice(t("Enter the test file path"));
            return;
          }
          const uploadResult = await this.plugin.uploadServe(this.plugin.settings.testFilePath);
          new import_obsidian2.Notice(uploadResult.success ? t("Upload successful") : t("Upload failed") + uploadResult.errorMessage);
        });
      });
    });
    containerEl.createEl("h2", { text: t("Upload rules") });
    new import_obsidian2.Setting(containerEl).setName(t("Attachment format to be uploaded")).setDesc(
      t(
        "The file in the configuration format will be uploaded when the command is executed and the original address will be replaced with the network address. The format will be separated by carriage returns."
      )
    ).addTextArea((textArea) => {
      textArea.setValue(this.plugin.settings.uploadFileFormat).onChange(async (value) => {
        this.plugin.settings.uploadFileFormat = value;
        await this.plugin.saveSettings();
      });
      textArea.inputEl.style.height = "150px";
    });
    new import_obsidian2.Setting(containerEl).setName(t("Delete local files after successful upload")).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.isDeleteSourceFile).onChange(async (value) => {
        this.plugin.settings.isDeleteSourceFile = value;
        await this.plugin.saveSettings();
      });
    });
  }
};
